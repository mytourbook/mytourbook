////////////////////////////////////////////////////////////////////////////////
// The following FIT Protocol software provided may be used with FIT protocol
// devices only and remains the copyrighted property of Dynastream Innovations Inc.
// The software is being provided on an "as-is" basis and as an accommodation,
// and therefore all warranties, representations, or guarantees of any kind
// (whether express, implied or statutory) including, without limitation,
// warranties of merchantability, non-infringement, or fitness for a particular
// purpose, are specifically disclaimed.
//
// Copyright 2008 Dynastream Innovations Inc.
////////////////////////////////////////////////////////////////////////////////
// ****WARNING****  This file is auto-generated!  Do NOT edit this file.
// Profile Version = 1.20Release
// Tag = $Name: AKW1_200 $
////////////////////////////////////////////////////////////////////////////////


package com.garmin.fit;

import java.io.ByteArrayOutputStream;
import java.io.DataOutputStream;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.DataInputStream;
import java.io.UnsupportedEncodingException;
import java.util.ArrayList;
import java.io.OutputStreamWriter;

public class Field {
   protected String name;
   protected int num;
   protected int type;
   protected double scale;
   protected double offset;
   protected String units;
   protected ArrayList<Object> values;
   protected ArrayList<FieldComponent> components;

   public Field(final Field field) {
      if (field == null) {
         this.name = "unknown";
         this.num = Fit.FIELD_NUM_INVALID;
         this.type = 0;
         this.scale = 1;
         this.offset = 1;
         this.units = "";
         this.values = new ArrayList<Object>();
         this.components = new ArrayList<FieldComponent>();
         return;
      }

      this.name = new String(field.name);
      this.num = field.num;
      this.type = field.type;
      this.scale = field.scale;
      this.offset = field.offset;
      this.units = new String(field.units);
      this.values = new ArrayList<Object>();
      for (Object value : field.values) {
         if (value instanceof Byte) {
            this.values.add(new Byte((Byte) value));
         } else if (value instanceof Short) {
            this.values.add(new Short((Short) value));
         } else if (value instanceof Integer) {
            this.values.add(new Integer((Integer) value));
         } else if (value instanceof Long) {
            this.values.add(new Long((Long) value));
         } else if (value instanceof Float) {
            this.values.add(new Float((Float) value));
         } else if (value instanceof Double) {
            this.values.add(new Double((Double) value));
         } else if (value instanceof String) {
            this.values.add(new String((String) value));
         }
      }
      this.components = field.components;
   }

   protected Field(String name, int num, int type, double scale, double offset, String units) {
      this.name = new String(name);
      this.num = num;
      this.type = type;
      this.scale = scale;
      this.offset = offset;
      this.units = new String(units);
      this.values = new ArrayList<Object>();
      this.components = new ArrayList<FieldComponent>();
   }
   
   public String getName() {
      return name;
   }

   public int getNum() {
      return num;
   }
   
   public int getType() {
      return type;
   }

   public String getUnits() {
      return units;
   }

   protected int getSize() {
      int size = 0;
      
      switch (type) {
         case Fit.BASE_TYPE_ENUM:
         case Fit.BASE_TYPE_UINT8:
         case Fit.BASE_TYPE_UINT8Z:
         case Fit.BASE_TYPE_SINT8:
         case Fit.BASE_TYPE_BYTE:
         case Fit.BASE_TYPE_SINT16:
         case Fit.BASE_TYPE_UINT16:
         case Fit.BASE_TYPE_UINT16Z:
         case Fit.BASE_TYPE_SINT32:
         case Fit.BASE_TYPE_UINT32:
         case Fit.BASE_TYPE_UINT32Z:
         case Fit.BASE_TYPE_FLOAT32:
         case Fit.BASE_TYPE_FLOAT64:
            size = getNumValues() * Fit.baseTypeSizes[type & Fit.BASE_TYPE_NUM_MASK];
            break;
            
         case Fit.BASE_TYPE_STRING:
            for (Object value : values) {
               try {
                  size += value.toString().getBytes("UTF-8").length + 1;
               } catch (UnsupportedEncodingException e) {
               }
            }
            break;
            
         default:
            break;
      }
      
      return size;
   }

   protected boolean isSignedInteger() {
      switch (type) {
         case Fit.BASE_TYPE_SINT8:
         case Fit.BASE_TYPE_SINT16:
         case Fit.BASE_TYPE_SINT32:
            return true;

         default:
            break;
      }

      return false;
   }

   public void addValue(Object value) {
      if ((value instanceof Number) && (type == Fit.BASE_TYPE_STRING)) {
         String string = getStringValue();
         Number number = (Number) value;

         if (string == null)
            string = "";

         string += String.valueOf((char) (number.intValue()));
         setValue(string);
         return;
      }

      values.add(value);
   }

   public int getNumValues() {
      return values.size();
   }

   public Object getValue() {
      return getValue(0);
   }

   public Object getValue(int index) {
      Object value;

      if (index >= values.size())
         return null;

      value = values.get(index);

      if ((value instanceof Number) && ((scale != 1) || (offset != 0))) {
         return new Double(((Number) value).doubleValue() / scale - offset);
      }

      return value;
   }

   public void setValue(Object value) {
      setValue(0, value);
   }

   public void setValue(int index, Object value) {
      while (index >= getNumValues())
         addValue(new Object());
      
      if (value == null) {
         values.set(index, null);
      } else if ((value instanceof Number) && ((scale != 1) || (offset != 0))) {
         values.set(index, (((Number) value).doubleValue() + offset) * scale);
      } else {
         values.set(index, value);
      }
   }

   public Long getBitsValue(int offset, int bits, boolean signed) {
      long value = 0;
      int bitsInValue = 0;
      int bitsInData;
      int index = 0;
      Long data;
      long mask;

      while (bitsInValue < bits) {
         data = getLongValue(index++);

         if (data == null)
            return null;

         data >>= offset;
         bitsInData = Fit.baseTypeSizes[type & Fit.BASE_TYPE_NUM_MASK] * 8 - offset;
         offset -= Fit.baseTypeSizes[type & Fit.BASE_TYPE_NUM_MASK] * 8;

         if (bitsInData > 0) {
            offset = 0;

            if (bitsInData > (bits - bitsInValue))
               bitsInData = bits - bitsInValue;

            mask = ((long) 1 << bitsInData) - 1;
            value |= ((long) data.longValue() & mask) << bitsInValue;
            bitsInValue += bitsInData;
         }
      }

      if (signed) {
         long signBit = (1L << (bits - 1));
         if ((value & signBit) != 0) {
            value = -signBit + (value & (signBit - 1));
         }
      }

      return value;
   }

   public Byte getByteValue() {
      return getByteValue(0);
   }

   public Byte getByteValue(int index) {
      Object value = getValue(index);

      if (value == null)
         return null;

      return ((Number) value).byteValue();
   }

   public Short getShortValue() {
      return getShortValue(0);
   }

   public Short getShortValue(int index) {
      Object value = getValue(index);

      if (value == null)
         return null;

      return ((Number) value).shortValue();
   }

   public Integer getIntegerValue() {
      return getIntegerValue(0);
   }

   public Integer getIntegerValue(int index) {
      Object value = getValue(index);

      if (value == null)
         return null;

      return ((Number) value).intValue();
   }

   public Long getLongValue() {
      return getLongValue(0);
   }

   public Long getLongValue(int index) {
      Object value = getValue(index);

      if (value == null)
         return null;

      return ((Number) value).longValue();
   }

   public Float getFloatValue() {
      return getFloatValue(0);
   }

   public Float getFloatValue(int index) {
      Object value = getValue(index);

      if (value == null)
         return null;

      return new Float(((Number) value).doubleValue());
   }

   public Double getDoubleValue() {
      return getDoubleValue(0);
   }

   public Double getDoubleValue(int index) {
      Object value = getValue(index);

      if (value == null)
         return null;

      return new Double(((Number) value).doubleValue());
   }

   public String getStringValue() {
      return getStringValue(0);
   }

   public String getStringValue(int index) {
      Object value = getValue(index);

      if (value == null)
         return null;

      return value.toString();
   }

   protected boolean read(InputStream in, int size) {
      try {
         DataInputStream data = new DataInputStream(in);
         if (type == Fit.BASE_TYPE_STRING) {
            try {
               ByteArrayOutputStream buffer = new ByteArrayOutputStream();
               int emptyStrings = 0;
               
               for (int i=0; i<size; i++)
               {
                  int b = in.read();
                  if (b == 0) {
                     if (buffer.size() > 0) {
                        while (emptyStrings > 0) {
                           values.add(new String());
                           emptyStrings--;
                        }
                        
                        values.add(new String(buffer.toByteArray(), "UTF-8"));
                     } else {
                        emptyStrings++;
                     }
                     
                     buffer.reset();
                  } else {
                     buffer.write(b);
                  }
               }
               if (buffer.size() > 0)
                  values.add(new String(buffer.toByteArray(), "UTF-8"));
            } catch (java.io.EOFException e) {
               return true;
            }            
         } else {
         int bytesLeft = size;

         while (bytesLeft > 0) {
            switch (type) {
               case Fit.BASE_TYPE_ENUM: {
                  Short value = (short) (data.readByte() & 0xFF);
                  if (!value.equals(Fit.ENUM_INVALID))
                     values.add(value);
                  break;
               }

               case Fit.BASE_TYPE_UINT8: {
                  Short value = (short) (data.readByte() & 0xFF);
                  if (!value.equals(Fit.UINT8_INVALID))
                     values.add(value);
                  break;
               }

               case Fit.BASE_TYPE_UINT8Z: {
                  Short value = (short) (data.readByte() & 0xFF);
                  if (!value.equals(Fit.UINT8Z_INVALID))
                     values.add(value);
                  break;
               }

               case Fit.BASE_TYPE_SINT8: {
                  Byte value = data.readByte();
                  if (!value.equals(Fit.SINT8_INVALID))
                     values.add(value);
                  break;
               }

               case Fit.BASE_TYPE_SINT16: {
                  Short value = data.readShort();
                  if (!value.equals(Fit.SINT16_INVALID))
                     values.add(value);
                  break;
               }

               case Fit.BASE_TYPE_UINT16: {
                  Integer value = data.readByte() & 0xFF;
                  value <<= 8;
                  value |= data.readByte() & 0xFF;
                  if (!value.equals(Fit.UINT16_INVALID))
                     values.add(value);
                  break;
               }

               case Fit.BASE_TYPE_UINT16Z: {
                  Integer value = data.readByte() & 0xFF;
                  value <<= 8;
                  value |= data.readByte() & 0xFF;
                  if (!value.equals(Fit.UINT16Z_INVALID))
                     values.add(value);
                  break;
               }

               case Fit.BASE_TYPE_SINT32: {
                  Integer value = data.readInt();
                  if (!value.equals(Fit.SINT32_INVALID))
                     values.add(value);
                  break;
               }

               case Fit.BASE_TYPE_UINT32: {
                  Long value = (long) (data.readByte() & 0xFF);
                  value <<= 8;
                  value |= data.readByte() & 0xFF;
                  value <<= 8;
                  value |= data.readByte() & 0xFF;
                  value <<= 8;
                  value |= data.readByte() & 0xFF;
                  if (!value.equals(Fit.UINT32_INVALID))
                     values.add(value);
                  break;
               }

               case Fit.BASE_TYPE_UINT32Z: {
                  Long value = (long) (data.readByte() & 0xFF);
                  value <<= 8;
                  value |= data.readByte() & 0xFF;
                  value <<= 8;
                  value |= data.readByte() & 0xFF;
                  value <<= 8;
                  value |= data.readByte() & 0xFF;
                  if (!value.equals(Fit.UINT32Z_INVALID))
                     values.add(value);
                  break;
               }

               case Fit.BASE_TYPE_FLOAT32: {
                  Float value = data.readFloat();
                  if (!value.equals(Fit.FLOAT32_INVALID))
                     values.add(value);
                  break;
               }

               case Fit.BASE_TYPE_FLOAT64: {
                  Double value = data.readDouble();
                  if (!value.equals(Fit.FLOAT64_INVALID))
                     values.add(value);
                  break;
               }

               case Fit.BASE_TYPE_BYTE: {
                  Short value;
                  boolean invalid = true;

                  while (bytesLeft-- > 0) {
                     value = (short) (data.readByte() & 0xFF);
                     values.add(value);
                     if (!value.equals(Fit.BYTE_INVALID))
                        invalid = false;
                  }

                  if (invalid)
                     values.clear();
                  break;
               }

               default:
                  return false;
            }

            bytesLeft -= Fit.baseTypeSizes[type & Fit.BASE_TYPE_NUM_MASK];
            }
         }
      } catch (java.io.IOException e) {
         return false;
      }

      return true;
   }

   protected void write(OutputStream out, FieldDefinition fieldDef) {
      int bytesLeft = fieldDef.size - getSize();
      
      write(out);
      
      // Fill remaining bytes with invalid.
      while (bytesLeft > 0) {
         writeValue(out, null);
         bytesLeft -= Fit.baseTypeSizes[type & Fit.BASE_TYPE_NUM_MASK];
      }
   }
   
   protected void write(OutputStream out) {
      for (Object value : values) {
         writeValue(out, value);
      }
   }

   private void writeValue(OutputStream out, Object value) {
      try {
         DataOutputStream data = new DataOutputStream(out);
         
         if (value == null) {
            switch (type) {
               case Fit.BASE_TYPE_ENUM:
                  data.writeByte(Fit.ENUM_INVALID);
                  break;
               case Fit.BASE_TYPE_UINT8:
                  data.writeByte(Fit.UINT8_INVALID);
                  break;
               case Fit.BASE_TYPE_UINT8Z:
                  data.writeByte(Fit.UINT8Z_INVALID);
                  break;
               case Fit.BASE_TYPE_SINT8:
                  data.writeByte(Fit.SINT8_INVALID);
                  break;
               case Fit.BASE_TYPE_BYTE:
                  data.writeByte(Fit.BYTE_INVALID);
                  break;
               case Fit.BASE_TYPE_SINT16:
                  data.writeShort(Fit.SINT16_INVALID);
                  break;
               case Fit.BASE_TYPE_UINT16:
                  data.writeShort(Fit.UINT16_INVALID);
                  break;
               case Fit.BASE_TYPE_UINT16Z:
                  data.writeShort(Fit.UINT16Z_INVALID);
                  break;
               case Fit.BASE_TYPE_SINT32:
                  data.writeInt(Fit.SINT32_INVALID);
                  break;
               case Fit.BASE_TYPE_UINT32:
                  data.writeInt((int)Fit.UINT32_INVALID.longValue());
                  break;
               case Fit.BASE_TYPE_UINT32Z:
                  data.writeInt((int)Fit.UINT32Z_INVALID.longValue());
                  break;
               case Fit.BASE_TYPE_STRING:
                  data.writeByte(0);
                  break;
               case Fit.BASE_TYPE_FLOAT32:
                  data.writeFloat(Fit.FLOAT32_INVALID);
                  break;
               case Fit.BASE_TYPE_FLOAT64:
                  data.writeDouble(Fit.FLOAT64_INVALID);
                  break;
               default:
                  break;
            }
         } else { // if (value != null)
            switch (type) {
               case Fit.BASE_TYPE_ENUM:
               case Fit.BASE_TYPE_UINT8:
               case Fit.BASE_TYPE_UINT8Z:
               case Fit.BASE_TYPE_SINT8:
               case Fit.BASE_TYPE_BYTE: {
                  if (value instanceof String)
                     System.err.printf("Field.write(): Field %s value should not be string value %s\n", name, value);
                  data.writeByte((int)Math.round(((Number) value).doubleValue()));
                  break;
               }
   
               case Fit.BASE_TYPE_SINT16:
               case Fit.BASE_TYPE_UINT16:
               case Fit.BASE_TYPE_UINT16Z: {
                  data.writeShort((int)Math.round(((Number) value).doubleValue()));
                  break;
               }
   
               case Fit.BASE_TYPE_SINT32:
               case Fit.BASE_TYPE_UINT32:
               case Fit.BASE_TYPE_UINT32Z: {
                  data.writeInt((int)Math.round(((Number) value).doubleValue()));
                  break;
               }
   
               case Fit.BASE_TYPE_STRING: {
                  OutputStreamWriter stringWriter = new OutputStreamWriter(out, "UTF-8");                  
                  stringWriter.write(value.toString());
                  stringWriter.flush();
                  out.write(0);
                  break;
               }
   
               case Fit.BASE_TYPE_FLOAT32: {
                  data.writeFloat(((Number) value).floatValue());
                  break;
               }
   
               case Fit.BASE_TYPE_FLOAT64: {
                  data.writeDouble(((Number) value).doubleValue());
                  break;
               }
   
               default:
                  break;
            }
         } // if (value != null)
      } catch (java.io.IOException e) {
      }
   }

}